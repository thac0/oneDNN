<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Intel(R) MKL-DNN: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Intel(R) Math Kernel Library for Deep Neural Networks (Intel(R) MKL-DNN)
   &#160;<span id="projectnumber">0.18.1</span>
   </div>
   <div id="projectbrief">Performance library for Deep Learning</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Intel(R) MKL-DNN Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Intel(R) Math Kernel Library for Deep Neural Networks (Intel(R) MKL-DNN) is an open source performance library for Deep Learning (DL) applications intended for acceleration of DL frameworks on Intel(R) architecture. Intel MKL-DNN includes highly vectorized and threaded building blocks for implementation of convolutional neural networks (CNNs) and reccurent neural networks (RNNs) with C and C++ interfaces. This project is created to help the DL community innovate on the Intel(R) processor family.</p>
<p>The library provides optimized implementations for the most common computational functions (also called primitives) used in deep neural networks covering a wide range of applications, including image recognition, object detection, semantic segmentation, neural machine translation, and speech recognition. The table below summarizes the list of supported functions and their variants.</p>
<table class="doxtable">
<tr>
<th align="left">Primitive class </th><th align="left">Primitive </th><th align="center">fp32 training </th><th align="center">fp32 inference </th><th align="center">int8 inference  </th></tr>
<tr>
<td align="left">Convolution </td><td align="left">1D direct convolution </td><td align="center">x </td><td align="center">x </td><td align="center"></td></tr>
<tr>
<td align="left"></td><td align="left">2D direct convolution </td><td align="center">x </td><td align="center">x </td><td align="center">x </td></tr>
<tr>
<td align="left"></td><td align="left">2D direct deconvolution </td><td align="center">x </td><td align="center">x </td><td align="center">x </td></tr>
<tr>
<td align="left"></td><td align="left">2D winograd convolution </td><td align="center">x </td><td align="center">x </td><td align="center">x </td></tr>
<tr>
<td align="left"></td><td align="left">3D direct convolution </td><td align="center">x </td><td align="center">x </td><td align="center"></td></tr>
<tr>
<td align="left"></td><td align="left">3D direct deconvolution </td><td align="center">x </td><td align="center">x </td><td align="center"></td></tr>
<tr>
<td align="left">Inner Product </td><td align="left">2D inner product </td><td align="center">x </td><td align="center">x </td><td align="center">x </td></tr>
<tr>
<td align="left"></td><td align="left">3D inner product </td><td align="center">x </td><td align="center">x </td><td align="center"></td></tr>
<tr>
<td align="left">RNN </td><td align="left">Vanilla RNN cell </td><td align="center">x </td><td align="center">x </td><td align="center">x </td></tr>
<tr>
<td align="left"></td><td align="left">LSTM cell </td><td align="center">x </td><td align="center">x </td><td align="center"></td></tr>
<tr>
<td align="left"></td><td align="left">GRU cell </td><td align="center">x </td><td align="center">x </td><td align="center"></td></tr>
<tr>
<td align="left">Pooling </td><td align="left">2D maximum pooling </td><td align="center">x </td><td align="center">x </td><td align="center">x </td></tr>
<tr>
<td align="left"></td><td align="left">2D average pooling </td><td align="center">x </td><td align="center">x </td><td align="center">x </td></tr>
<tr>
<td align="left"></td><td align="left">3D maximum pooling </td><td align="center">x </td><td align="center">x </td><td align="center"></td></tr>
<tr>
<td align="left"></td><td align="left">3D average pooling </td><td align="center">x </td><td align="center">x </td><td align="center"></td></tr>
<tr>
<td align="left">Normalization </td><td align="left">2D LRN (within channel) </td><td align="center">x </td><td align="center">x </td><td align="center"></td></tr>
<tr>
<td align="left"></td><td align="left">2D LRN (across channels) </td><td align="center">x </td><td align="center">x </td><td align="center"></td></tr>
<tr>
<td align="left"></td><td align="left">2D batch normalization </td><td align="center">x </td><td align="center">x </td><td align="center"></td></tr>
<tr>
<td align="left"></td><td align="left">3D Batch Normalization </td><td align="center">x </td><td align="center">x </td><td align="center"></td></tr>
<tr>
<td align="left">Activation </td><td align="left">ReLU </td><td align="center">x </td><td align="center">x </td><td align="center">x </td></tr>
<tr>
<td align="left"></td><td align="left">Tanh </td><td align="center"></td><td align="center">x </td><td align="center"></td></tr>
<tr>
<td align="left"></td><td align="left">ELU </td><td align="center"></td><td align="center">x </td><td align="center"></td></tr>
<tr>
<td align="left"></td><td align="left">Bounded ReLU </td><td align="center"></td><td align="center">x </td><td align="center"></td></tr>
<tr>
<td align="left"></td><td align="left">Soft ReLU </td><td align="center"></td><td align="center">x </td><td align="center"></td></tr>
<tr>
<td align="left"></td><td align="left">Logistic regression </td><td align="center"></td><td align="center">x </td><td align="center"></td></tr>
<tr>
<td align="left"></td><td align="left">Softmax </td><td align="center">x </td><td align="center">x </td><td align="center"></td></tr>
<tr>
<td align="left">Data manipulation </td><td align="left">Reorder/quantization </td><td align="center">x </td><td align="center">x </td><td align="center">x </td></tr>
<tr>
<td align="left"></td><td align="left">Sum </td><td align="center">x </td><td align="center">x </td><td align="center">x </td></tr>
<tr>
<td align="left"></td><td align="left">Concat </td><td align="center">x </td><td align="center">x </td><td align="center">x </td></tr>
<tr>
<td align="left"></td><td align="left">Elementwise operations </td><td align="center"></td><td align="center">x </td><td align="center"></td></tr>
<tr>
<td align="left"></td><td align="left">Channel Shuffle </td><td align="center">x </td><td align="center">x </td><td align="center">x </td></tr>
</table>
<h2>Programming Model</h2>
<p>Intel MKL-DNN models memory as a primitive similar to an operation primitive. This allows reconstruction of the graph of computations at run time.</p>
<h3>Basic Terminology</h3>
<p>Intel MKL-DNN operates on the following main objects:</p>
<ul>
<li><b>Primitive</b> - any operation, such as convolution, data format reordering, and even memory. Primitives can have other primitives as inputs, but can have only memory primitives as outputs.</li>
<li><b>Engine</b> - an execution device. Currently the only supported engine is CPU. Every primitive is mapped to a specific engine.</li>
<li><b>Stream</b> - an execution context. You submit primitives to a stream and wait for their completion. Primitives submitted to the same stream can have different engines. The stream also tracks dependencies between the primitives.</li>
</ul>
<p>A typical workflow is to create a set of primitives to run, push them to a stream all at once or one at a time, and wait for completion.</p>
<h3>Creating Primitives</h3>
<p>In Intel MKL-DNN, creating primitives involves three levels of abstraction:</p>
<ul>
<li><b>Operation/memory descriptor</b> - a high-level description with logical parameters of an operation or memory. It is a lightweight structure that does not allocate any physical memory or computation resources.</li>
<li><b>Primitive descriptor</b> - a complete description of a primitive that contains an operation descriptor, descriptors of primitive inputs and outputs, and the target engine. This permits future API extensions to enable querying the descriptor for estimated performance, memory consumptions, and so on. A primitive descriptor is also a lightweight structure.</li>
<li><b>Primitive</b> - a specific instance of a primitive created using the corresponding primitive descriptor. A primitive structure contains pointers to input primitives and output memory. Creating a primitive is a potentially expensive operation because when a primitive is created, Intel MKL-DNN allocates the necessary resources to execute the primitive.</li>
</ul>
<p>To create a memory primitive:</p>
<ol type="1">
<li>Create a memory descriptor. The memory descriptor contains the dimensions, precision, and format of the data layout in memory. The data layout can be either user-specified or set to <code>any</code>. The <code>any</code> format allows the operation primitives (convolution and inner product) to choose the best memory format for optimal performance.</li>
<li>Create a memory primitive descriptor. The memory primitive descriptor contains the memory descriptor and the target engine.</li>
<li>Create a memory primitive. The memory primitive requires allocating a memory buffer and attaching the data handle to the memory primitive descriptor. <b>Note:</b> in the C++ API for creating an output memory primitive, you do not need to allocate buffer unless the output is needed in a user-defined format.</li>
</ol>
<p>To create an operation primitive:</p>
<ol type="1">
<li>Create a logical description of the operation. For example, the description of a convolution operation contains parameters such as sizes, strides, and propagation type. It also contains the input and output memory descriptors.</li>
<li>Create a primitive descriptor by attaching the target engine to the logical description.</li>
<li>Create an instance of the primitive and specify the input and output primitives.</li>
</ol>
<h2>Examples</h2>
<p>A walk-through example for implementing an AlexNet topology using the c++ API:</p>
<ul>
<li><a class="el" href="ex_simplenet.html">SimpleNet Example</a></li>
</ul>
<p>An introductory example to low-precision 8-bit computations:</p>
<ul>
<li><a class="el" href="ex_int8_simplenet.html">Int8 SimpleNet Example</a></li>
</ul>
<p>The following examples are available in the /examples directory and provide more details about the API.</p>
<ul>
<li>Creation of forward primitives<ul>
<li>C: simple_net.c</li>
<li>C++: simple_net.cpp</li>
</ul>
</li>
<li>Creation of full training net (forward and backward primitives)<ul>
<li>C: simple_training.c</li>
<li>C++: simple_training_net.cpp</li>
</ul>
</li>
<li>Creation of forward propagation of GNMT topology<ul>
<li>C++: simple_rnn.cpp</li>
</ul>
</li>
<li>Training RNN with sequences of variable length<ul>
<li>C++: simple_rnn_training.cpp</li>
</ul>
</li>
</ul>
<h3>Performance Considerations</h3>
<ul>
<li>Convolution and inner product primitives choose the memory format when you create them with the unspecified memory format <code>any</code> for input or output. The memory format chosen is based on different circumstances such as hardware and convolutional parameters.</li>
<li>Convolution could be executed using the <a class="el" href="winograd_convolution.html">Winograd algorithm</a> for a significant performance boost.</li>
<li>Operation primitives (such as ReLU, LRN, or pooling) following convolution or inner product, should have input in the same memory format as the convolution or inner-product. Reordering can be an expensive operation, so you should avoid it unless it is necessary for performance in convolution, inner product, or output specifications.</li>
<li>Pooling, concat and sum can be created with the output memory format <code>any</code>.</li>
<li>An operation primitive (typically operations such as pooling, LRN, or softmax) might need workspace memory for storing results of intermediate operations that help with backward propagation.</li>
</ul>
<p>The following link provides a guide to MKLDNN verbose mode for profiling execution:</p>
<ul>
<li><a class="el" href="perf_profile.html">Performance profiling</a></li>
</ul>
<h3>Operational Details</h3>
<ul>
<li>You might need to create a reorder primitive to convert the data from a user format to the format preferred by convolution or inner product.</li>
<li>All operations should be queried for workspace memory requirements. If workspace is needed, it should only be created during the forward propagation and then shared with the corresponding primitive on backward propagation.</li>
<li>A primitive descriptor from forward propagation must be provided while creating corresponding primitive descriptor for backward propagation. This tells the backward operation what exact implementation is chosen for the primitive on forward propagation. This in turn helps the backward operation to decode the workspace memory correctly.</li>
<li><p class="startli">You should always check the correspondence between current data format and the format that is required by a primitive. For instance, forward convolution and backward convolution with respect to source might choose different memory formats for weights (if created with <code>any</code>). In this case, you should create a reorder primitive for weights. Similarly, a reorder primitive might be required for a source data between forward convolution and backward convolution with respect to weights.</p>
<p class="startli"><b>Note:</b> Please refer to extended examples to illustrate these details.</p>
</li>
</ul>
<h3>Auxiliary Types</h3>
<ul>
<li><b>Primitive_at</b> - a structure that contains a primitive and an index. This structure specifies which output of the primitive to use as an input for another primitive. For a memory primitive the index is always <code>0</code> because it does not have a output.</li>
</ul>
<h2>Architecture and design of Intel MKL-DNN</h2>
<p>For better understanding the architecture and design of Intel MKL-DNN as well as the concepts used in the library please read the following topics:</p>
<p><a class="el" href="understanding_memory_formats.html">Understanding Memory Formats</a></p>
<hr/>
<p><a class="el" href="legal_information.html">Legal information</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
